{"pageProps":{"id":"programming_languages","meta":{"title":"Языки программирования","publishedAt":"2024-04-30T19:44:00.000Z"},"content":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    a: \"a\",\n    ol: \"ol\",\n    li: \"li\",\n    code: \"code\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Язык программирования по смыслу ничем не отличается от обычного языка общения: английский, русский, китайский и т. д. Назначение обычного языка — передавать информацию от одного человека другому. Программисту же необходимо передать информацию компьютеру.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"как-общаться\",\n      children: [\"Как общаться?\", _jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#как-общаться\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Если надо кому-либо объяснить как сделать что-то мы рассказываем последовательность действий. Хороший пример — рецепт какого-нибудь блюда. Допустим тебе надо научить кого-то делать бутерброд с вареньем, тогда инструкция может выглядеть так:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Берешь кусочек хлеба\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Намазываешь на него любимое варенье\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Вуаля бутерброд с вареньем готов!\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Но если тебе надо научить компьютер делать бутерброд с вареньем, то все будет «немного» сложнее.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Компьютер в отличии от человека не имеет накопленного опыта. «А в чем проблема?» спросишь ты. Проблема в том что компьютер не умеет открывать банки с вареньем или например, не знает что не стоит намазывать варенье ногой. В инструкции опущено очень много деталей которые и так понятны человеку, но компьютер это чистый лист и инструкция для него должна быть очень подробной.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Набор инструкций компьютеру называется программой и пишутся эти инструкции на языках программирования.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"инструкции\",\n      children: [\"Инструкции\", _jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#инструкции\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"На самом низком уровне общение с компьютером ограничивается нулями и единицами — двоичная система или машинный код. Человеку практически невозможно читать код состоящий только из \", _jsx(_components.code, {\n        children: \"0\"\n      }), \" и \", _jsx(_components.code, {\n        children: \"1\"\n      }), \", а писать такой код конечно можно попробовать, но тогда придется заниматься постоянным переводом в двоичный код. Например буква «A» в двоичной системе выглядит как \", _jsx(_components.code, {\n        children: \"01000001\"\n      }), \". С таким успехом код, даже небольшой программы, будет занимать сотни строк.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Для более удобного общения с компьютером был придуман язык Assembly. Вот так выглядит код программы которая пишет «Hello world!»\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-assembly\",\n        children: \"section        .text           \\nglobal         _start            \\n_start:  \\n    mov edx, len   \\n    mov ecx, msg   \\n    mov ebx, 1  \\n    mov eax, 4  \\n    int 0x80  \\n    mov eax, 1  \\n    int 0x80section        .data               \\n    msg        db \\\"Hello world!\\\", 0xa  \\n    len        equ $ -msg\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Местами даже можно прочитать и понять отдельные слова, но все-таки это довольно близко к машинному коду и писать большие программы будет сложно.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"«Под капотом» у Assembly все те же нули и единицы. Получается как бы язык Assembly поверх бинарного языка. В программировании такое называется \", _jsx(_components.strong, {\n        children: \"уровнем абстракции\"\n      }), \" языка.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Существует разделение языков программирования по уровню абстракции:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Высокоуровневые\"\n        }), \" (Java, Python, Ruby, C# и т. д.)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Среднеуровневые\"\n        }), \" (С, С++, RUST)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Низкоуровневые\"\n        }), \" (Forth, CIL, Assembly)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Чем ближе язык к машинному коду тем он более низкоуровневый.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"перевод-намашинный-язык\",\n      children: [\"Перевод на машинный язык\", _jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#перевод-намашинный-язык\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Когда мы общаемся мы переводим наши мысли на язык понятный тому кому необходимо донести информацию. Так же и компьютер использует переводчик — \", _jsx(_components.strong, {\n        children: \"компилятор\"\n      }), \", который превращает код написанный человеком в машинный код.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Существует и другой способ писать программы — с помощью \", _jsx(_components.strong, {\n        children: \"интерпретатора\"\n      }), \". Представь ты отправился в путешествие, но языка не знаешь и в общении тебе помогает переводчик — интерпретирует сказанные тобой слова на нужный язык.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Языки делятся и по способу исполнения их компьютером:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"Компилируемые\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"Интерпретируемые\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Компилируемый язык, это как подготовка тщательно продуманного выступления. Ты пишешь свой текст заранее, редактируешь его, исправляешь ошибки и только после этого выходишь на сцену, чтобы исполнить своё выступление. Твой текст компилируется в специальную форму, которую зрители могут понять и оценить.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Теперь представь, что ты даёшь выступление на импровизированной сцене. Ты не знаешь заранее, что скажешь, но ты готов к любому повороту событий. Когда ты выходишь на сцену, зрители слушают тебя и сразу же реагируют на твои слова. В этом случае твои слова аналогичны командам в интерпретируемых языках программирования. Ты даёшь команды (код), и интерпретатор (или ты сам, если ты и есть интерпретатор) сразу же их выполняет, без предварительной компиляции.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Таким образом, основное отличие между компилируемыми и интерпретируемыми языками заключается в этапе преобразования и выполнения кода. В компилируемых языках код сначала компилируется в машинный код, а затем выполняется, в то время как в интерпретируемых языках код выполняется непосредственно интерпретатором на ходу.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},"__N_SSG":true}